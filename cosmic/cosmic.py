# -*- coding: utf-8 -*-
"""
This file contains the functions needed to compute the CosMIC metric score.

Author: Stephanie Reynolds
Supervisors: Pier Luigi Dragotti, Simon R Schultz
Date: 3rd July 2017
"""

import math
import numpy as np
from numpy import exp
from scipy.stats import norm
import scipy.optimize


def compute_score(width, t_k, tt_k):
    
    """ Applies the CosMIC metric.
    
    Arguments:
        width - The width of the triangular pulse with which the spike trains are convolved.
        t_k   - The true spike times.
        tt_k  - The estimated spike times. 
        
    Outputs:
        score         - Value of CosMIC score
        cos_precision - Value of the ancestor metric analogous to the precision
        cos_recall    - Value of the ancestor metric analogous to the recall
        y             - Pulse train (membership function) generated by convolution of true spike train and triangular pulse
        y_hat         - Pulse train (membership function) generated by convolution of true spike train and triangular pulse   
    """
    
    K     = len(t_k)
    K_hat = len(tt_k)
    
    if K == 0 or K_hat == 0:
        
        score         = 0
        cos_recall    = 0
        cos_precision = 0
        y             = []
        y_hat         = []
        
    else:
        
        # get time stamps of membership functions (pulse trains)
        dt      = width/50
        t_lower = min(min(t_k), min(tt_k)) + width     
        t_upper = max(max(t_k), max(tt_k)) + width         
        t       = np.arange(t_lower, t_upper, dt)
        t_len   = len(t)
        
        # maximum offset from spike to receive non-zero score
        dist    = width/2     
        
        # get membership function (pulse train) of true spikes
        t_mat                         = np.array([t,] * K)
        t_k_mat                       = np.array([t_k,] * t_len).transpose()
        time_delay                    = abs(np.subtract(t_mat, t_k_mat))
        time_delay[time_delay > dist] = dist
        weight                        = 1 - time_delay/dist
        y                             = np.sum(weight, axis = 0)
        
        # get membership function (pulse train) of estimated spikes
        t_mat                         = np.array([t,] * K_hat)
        tt_k_mat                      = np.array([tt_k,] * t_len).transpose()
        time_delay                    = abs(np.subtract(t_mat, tt_k_mat))
        time_delay[time_delay > dist] = dist
        weight                        = 1 - time_delay/dist
        y_hat                         = np.sum(weight, axis = 0)
                     
        # calculate scores
        intersection  = np.minimum(y, y_hat)
        score         = 2 * np.sum(intersection)/(np.sum(y) + np.sum(y_hat))
    
        # calculate scores of ancestor metrics
        cos_recall    = np.sum(intersection)/np.sum(y)
        cos_precision = np.sum(intersection)/np.sum(y_hat)

    
    return score, cos_precision, cos_recall, y, y_hat, t


def compute_crb(T, A, sigma2, alpha = 3.18, gamma = 34.49):
    
    """ Computes the Cramer-Rao bound (CRB) given the pulse paramters.
    
    We assume the following model of a calcium transient pulse:
        
        p(t) = A (exp(-alpha * t) - exp(-gamma * t)) 1_{t > 0},
        
    where 1 is the indicator function. Given the pulse paramters and the noise 
    variance (sigma2), we calculate the Cramer Rao bound on the uncertainty of 
    the estimated location of one spike.
    
    Arguments:
        T            - the sampling period of the fluorescence signal
        A            - amplitude of pulse (nB: not peak amplitude)
        sigma2       - sample variance of noise
        alpha, gamma - rise and decay parameters
        
    Output:
        CRB   - the Cramer-Rao bound    
    """
    
    # signal is sampled across interval [0, t_int] with time resolution T
    t_int     = 1
    N         = int(t_int / T)
    n_vec     = range(N)
    
    # CRB is averaged over multiple locations of the spike t_k
    N_star    = int(0.25*N//1)
    K         = 9
    t_k       = np.linspace((N_star + 0.1)*T, (N_star + 1)*T, K, False)
    
    # initialise fisher information
    fisher    = np.zeros(K)
    
    # compute fisher information
    for k in range(K):
        t_k_curr = t_k[k]
        for n in n_vec:
            u      = n * T - t_k_curr
            if u > 0:
                f_u        = (alpha * exp(-alpha * u) - gamma * exp(-gamma * u))**2;
                fisher[k] += f_u   
    
    # average over the spike times                  
    fisher = np.mean(fisher)* A ** 2
                    
    # crb is inverse of fisher information                 
    CRB    = np.divide(sigma2, fisher)         
    
    return CRB


def compute_metric_width(crb):
    
    """Computes width at which estimates at precision of CRB achieve avg. 0.8 score.
    
    The width of the metric is fitted so that estimates at the precision of the 
    CRB achieve, on average, a score of 0.8. 
    
    Arguments:
        crb: Cramer-Rao bound
    
    Output
        width: Width of triangular pulse used in CosMIC metric
    
    """
    
    c       = lambda width: norm.cdf(width, 0, np.sqrt(crb)) - 0.5
    f       = lambda width: norm.pdf(width, 0, np.sqrt(crb))
    score   = lambda width: (2*(c(width)*(crb/width**2 + 1) +crb/width*(f(width) - 2*f(0))))
    error   = lambda width: abs(score(width) - 0.8)
    width_0 = 7.3 * np.sqrt(crb)
    width   = scipy.optimize.fmin(func = error, x0 = width_0, disp= False)
    
    return width


def simulate_fluorescence_signal(t, t_k, a_k, alpha = 3.18, gamma = 34.39):
    
    """ Simulate fluorescence signal given model paramters.
    
    Arguments:
        t            - time stamps
        t_k          - spike times (list)
        a_k          - amplitudes (list)
        alpha, gamma - rise and decay parameters of pulse
        
    Output:
        f_hat - fluorescence signal
        
    """
    
    t_peak = math.log(gamma/alpha)/(gamma - alpha)
    c      = gamma*exp(alpha*t_peak)/(gamma - alpha)
    fhat   = np.zeros(t.size)
    K      = len(t_k)
    for k in range(K):
        spike_time = t_k[k]
        amplitude  = a_k[k] * c
        u_vec      = t - spike_time
        for i in range(len(t)):
            u = u_vec[i]
            if u > 0:
                f_u      = amplitude * (exp(-alpha*u) - exp(-gamma*u))
                fhat[i] += f_u
    return fhat;